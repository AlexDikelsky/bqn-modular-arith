โจ
  Xgcd,
  Gcd,
  Lcm,
  Crt,
  ModInverse,
  ZCross,
โฉโ


# Input: 2 integers
Xgcd โ {
  0 ๐ 0: โจ0, 0, 0โฉ ;
  0 ๐ b: โจb, 0, 1โฉ ;
  a ๐ b: {
    gโฟsโฟt โ (a | b) Xgcd a
    โจg, t - (s ร (โ b รท a)), sโฉ } }โ0

Gcd โ {
  0 โ ๐จ Xgcd ๐ฉ
}โ0

Lcm โ {
  (| ๐ฉ ร ๐จ) รท ๐ฉ Gcd ๐จ
}

# Input: โจa, m_1โฉ Crt โจb, m_2โฉ
Crt โ {
  a1โฟn1 โ ๐จ
  a2โฟn2 โ ๐ฉ
  gcdโฟm1โฟm2 โ n1 Xgcd n2
  ("Gcd of " โพ ('0' + n1) โพ " and " โพ ('0' + n2) โพ " isn't 1") ! gcd = 1
  x1 โ (a1 ร m2 ร n2) + (a2 ร m1 ร n1)
  x2 โ n1 ร n2
  sol โ x2 | x1
  โจsol, n1 ร n2โฉ
}โ1

ModInverse โ {
  aโฟm โ ๐ฉ 
  gโฟxโฟy โ a Xgcd m
  ! g = 1
  x
}โ1

# Probably a very slow way to do this
ZCross โ {
  n โ โ๐ฉ
  (1= ๐ฉ Gcd n) / n
}โ0
