âŸ¨
  Xgcd,
  Gcd,
  Crt,
  ModInverse,
  ZCross,
âŸ©â‡


# Input: 2 integers
Xgcd â† {
  0 ğ•Š 0: âŸ¨0, 0, 0âŸ© ;
  0 ğ•Š b: âŸ¨b, 0, 1âŸ© ;
  a ğ•Š b: {
    gâ€¿sâ€¿t â† (a | b) Xgcd a
    âŸ¨g, t - (s Ã— (âŒŠ b Ã· a)), sâŸ© } }âš‡0

Gcd â† {
  0 âŠ‘ ğ•¨ Xgcd ğ•©
}âš‡0

# Input: âŸ¨a, m_1âŸ© Crt âŸ¨b, m_2âŸ©
Crt â† {
  a1â€¿n1 â† ğ•¨
  a2â€¿n2 â† ğ•©
  gcdâ€¿m1â€¿m2 â† n1 Xgcd n2
  ("Gcd of " âˆ¾ ('0' + n1) âˆ¾ " and " âˆ¾ ('0' + n2) âˆ¾ " isn't 1") ! gcd = 1
  x1 â† (a1 Ã— m2 Ã— n2) + (a2 Ã— m1 Ã— n1)
  x2 â† n1 Ã— n2
  sol â† x2 | x1
  âŸ¨sol, n1 Ã— n2âŸ©
}âš‡1

ModInverse â† {
  aâ€¿m â† ğ•© 
  gâ€¿xâ€¿y â† a Xgcd m
  ! g = 1
  x
}âš‡1

# Probably a very slow way to do this
ZCross â† {
  n â† â†•ğ•©
  (1= ğ•© Gcd n) / n
}âš‡0
